# 23장. 실행 컨텍스트 p.359
실행 컨텍스트는
> 자바스크립트의 동작 원리를 담고 있는 핵심 개념

실행 컨텍스트를 바르게 이해하면
> 자바스크립트가 스코프를 기반으로 
식별자와 식별자에 바인딩된 값(식별자 바인딩)을 관리하는 방식과
호이스팅이 발생하는 이유,
클로저의 동작 방식,
태스크 큐와 함께 동작하는 이벤트 핸들러,
비동기 처리의 동작 방식
을 이해할 수 있다.
## 23.1 소스코드의 타입
ECMAScript 사양은 소스코드(ECMAScript code)를 4가지 타입으로 구분하며
> 이 소스코드는 실행 컨텍스트를 생성

(실행 가능한 코드 executable code) 소스코드를 4가지 타입으로 구분하는 이유
> 소스코드의 타입에 따라
실행 컨텍스트를 생성하는 과정과 관리 내용이 다르므로

소스코드 종류
> 전역, 함수, eval, 모듈 코드

전역 코드
> * 의미: 전역에 존재하는 소스코드
> * 포함하지 않는 코드: 전역에 정의된 함수, 클래스 등의 내부 코드
> * 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 함
> * var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를
전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 함
> * 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성됨

함수 코드
> * 의미: 함수 내부에 존재하는 소스코드
> * 포함하지 않는 코드: 함수 내부에 중첩된 함수, 클래스 등의 내부 코드
> * 지역 변수, 매개변수, arguments 객체를 관리하기 위해 지역 스코프를 생성해야 함
> * 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 함
> * 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성됨

eval 코드
> * 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드
> * strict mode（엄격 모드）에서 자신만의 독자적인 스코프를 생성함
> * 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성됨

모듈 코드
> * 의미: 모듈 내부에 존재하는 소스코드
> * 포함하지 않는 코드: 모듈 내부의 함수, 클래스 등의 내부 코드
> * 모듈별로 도립적인 모듈 스코프를 생성함
> * 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성됨
--------------------
## 23.2 소스코드의 평가와 실행
자바스크립트 엔진이 소스코드를 처리하는 과정
> 소스코드의 평가
> 소스코드의 실행
>> 2개의 과정으로 나누어 처리함

아래와 같은 소스코드가 실행된다고 하면
```js
var x;
x = 1;
```
소스코드 평가 과정에서
> 1) 실행 컨스트를 생성
> 2) 변수 선언문 var x; 실행
  이때 생성된 변수 식별자는
  실행 컨텍스트가 관리하는 스코프（렉시컬 환경의 환경 레코드）에 등록되고 undefined로 초기화됨

소스코드 실행 과정에서
> 1) 선언문 제외한 소스코드 순차적으로 실행 시작 (런타임 시작)
> 2) 변수 할당문 x = 1; 실행
> 3) 변수에 값을 할당하려면 x 변수가 선언된 변수인지 확인해야 하므로
실행 컨텍스트가 관리하는 스코프에 X 변수가 등록되어 있는지 확인
>> * 소스코드 실행에 필요한 정보 (변수나 함수의 참조)는
실행 컨텍스트가 관리하는 스코프에서 검색해서 취득함
> 4) X 변수가 선언된 변수라면 값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리
--------------------
## 23.3 실행 컨텍스트의 역할
실행 컨텍스트
> * 소스코드를 실행하는 데 필요한 환경을 제공, 코드의 실행 결과를 실제로 관리하는 영역

실행 컨텍스트가 관리하는 것
> 코드가 실행되기 위해 필요한 식별자, 스코프, 코드 실행 순서 등의 관리 필요
>> 1. 선언에 의해 생성된 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 함.
>> 2. 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 함.
>> 3. 현재 실행 중인 코드의 실행 순서를 변경할 수 있어야하며
다시 되돌아갈 수도 있어야 함.

식별자와 스코프
> 실행 컨텍스트의 렉시컬 환경으로 관리

코드 실행 순서
> 실행 컨텍스트 스택으로 관리
--------------------
## 23.4 실행 컨텍스트 스택
실행 컨텍스트 스택이란?
> 생성된 실행 컨텍스트를 스택 자료구조로 관리
코드의 실행 순서를 관리

스택의 최상위에 존재하는 실행 컨텍스트
> 언제나 현재 실행 중인 코드의 실행 컨텍스트

코드가 시행되는 시간의 흐름에 따라
> 실행 컨텍스트 스택에는 실행 컨텍스트가 추가되고 제거됨

--------------------

## 23.5 렉시컬 환경
렉시컬 환경
> * 식별자, 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조
> * 스코프와 식별자를 관리
> * 렉시컬 스코프 (스코프를 구분하여 식별자를 등록, 관리하는 저장소 역할)의 실체
> * 실행 컨텍스트를 구성하는 컴포넌트
> * 형태 = 키와 값을 갖는 객체 형태
키 (식별자) : 값 (식별자에 바인딩된 값)

실행 컨텍스트의 구성 컴포넌트
> LexicalEnvironment (렉시컬 환경)
> VariableEnvironment (변수 환경)

렉시컬 환경의 구성 컴포넌트
> EnvironmentRecord (환경 레코드)
> OuterLexicalEnvironmentReference (외부 렉시컬 환경에 대한 참조)

EnvironmentRecord (환경 레코드)
> 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소

OuterLexicalEnvironmentReference (외부 렉시컬 환경에 대한 참조)
> 외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킴
>> 이때의 상위 스코프란?
해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경

외부 렉시컬 환경에 대한 참조를 통해
> 단방향 링크드 리스트인 스코프 체인을 구현

생성 초기의 실행 컨텍스트의 두 컴포넌트가 하나의 동일한 렉시컬 환경을 참조
![생성 초기의 실행 컨텍스트와 렉시컬 환경](./%EC%83%9D%EC%84%B1%20%EC%B4%88%EA%B8%B0%EC%9D%98%20%EC%8B%A4%ED%96%89%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80%20%EB%A0%89%EC%8B%9C%EC%BB%AC%20%ED%99%98%EA%B2%BD.jpeg)


이후 몇 가지 상황을 만나면 VariableEnvironment 컴포넌트를 위한 새로운 렉시컬 환경을 생성하고, 이때부터 VariableEnvironment 컴포넌트와 LexicalEnvironment 컴포넌트는 내용이 달라지는 경우도 있다.